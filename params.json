{"name":"Ntfs-linker","tagline":"NTFS journal parser","body":"# NTFS-Linker\r\nAuthor: Zack Weger\r\n\r\nCopyright (c) 2015, [Stroz Friedberg, LLC](http://www.strozfriedberg.com)\r\n\r\nStatus: Alpha\r\n\r\n## Basic usage:\r\n\r\n    C:\\> ntfs-linker.exe --ntfs-dir .\\journals\\ --output .\\parsed-output\\\r\n\r\n    C:\\> ntfs-linker.exe --image MyEvidence.E01 --ntfs-dir .\\journals\\ --output .\\parsed-output\\\r\n\r\n## Input\r\n\r\n`ntfs-linker` operates off of a directory of input containing $UsnJrnl, \r\n$Logfile, and $MFT. The $UsnJrnl should be the $J alternate data stream and it \r\ncan be clipped to avoid copying the sparse portions.\r\n\r\n`ntfs-linker` can *also* work off of a nested directory structure like the one\r\nbelow. It can process multiple volumes, and each volume can have multiple\r\nvolume shadow copy directories. If a volume has no volume shadow copies, the\r\nintermediate `vss_base` folder can be omitted.\r\n\r\n    INPUT\r\n    └── volume_0\r\n        ├── vss_0\r\n        │   ├── $J\r\n        │   ├── $LogFile\r\n        │   └── $MFT\r\n        ├── vss_1\r\n        │   ├── $J\r\n        │   ├── $LogFile\r\n        │   └── $MFT\r\n        ├── vss_2\r\n        │   ├── $J\r\n        │   ├── $LogFile\r\n        │   └── $MFT\r\n        └── vss_base\r\n            ├── $J\r\n            ├── $LogFile\r\n            └── $MFT\r\n\r\nWhen presented with a disk image as input, `ntfs-linker` will automatically run \r\nagainst all NTFS volumes and retrieve the respective occurrences of $UsnJrnl,\r\n$Logfile, and $MFT. If a volume contains Volume Shadow Copies, the NTFS files\r\nwill be retrieved from each VSC and then the entire collection will be parsed.\r\nThe files will be copied out into a directory structure like the one above.\r\n\r\n## Output\r\n\r\nThe output will look like this:\r\n\r\n    OUTPUT\r\n    ├── ntfs.db\r\n    └── volume_0\r\n        ├── events.txt\r\n        ├── vss_0\r\n        │   ├── logfile.txt\r\n        │   └── usnjrnl.txt\r\n        ├── vss_1\r\n        │   ├── logfile.txt\r\n        │   └── usnjrnl.txt\r\n        ├── vss_2\r\n        │   ├── logfile.txt\r\n        │   └── usnjrnl.txt\r\n        └── vss_base\r\n            ├── logfile.txt\r\n            └── usnjrnl.txt\r\n\r\n`ntfs.db` is a SQLite database which contains data from all volume shadow copies\r\non all volumes. `events.txt` is a tab-separated report on all of the events from\r\na particular volume. If `--extra` is specified, then `logfile.txt` and `usnjrnl.txt`\r\nwill contain detailed information about the $LogFile and $UsnJrnl for a particular\r\nsnapshot.\r\n\r\n\r\n## Database schema\r\n\r\nThe SQLite database created by `ntfs-linker` will have the following structure:\r\n\r\n```\r\nCREATE TABLE event (\r\n    Position            int, \r\n    Timestamp           text, \r\n    EventSource         text, \r\n    EventType           text, \r\n    FileName            text, \r\n    Folder              text, \r\n    Full_Path           text, \r\n    MFT_Record          int, \r\n    Parent_MFT_Record   int, \r\n    USN_LSN             int, \r\n    Old_File_Name       text, \r\n    Old_Folder          text, \r\n    Old_Parent_ Record  int, \r\n    Offset              int, \r\n    Created             text, \r\n    Modified            text, \r\n    Comment             text, \r\n    Snapshot            text, \r\n    Volume              text\r\n)\r\n\r\nCREATE TABLE log (\r\n    CurrentLSN      int, \r\n    PrevLSN         int, \r\n    UndoLSN         int, \r\n    ClientID        int, \r\n    RecordType      int, \r\n    RedoOP          text, \r\n    UndoOP          text, \r\n    TargetAttribute int, \r\n    MFTClusterIndex int, \r\n    Offset          int, \r\n    Snapshot        text, \r\n    Volume          text\r\n)\r\n\r\nCREATE TABLE usn (\r\n    MFTRecNo        int, \r\n    ParRecNo        int, \r\n    USN             int, \r\n    Timestamp       text, \r\n    Reason          text, \r\n    FileName        text, \r\n    PossiblePath    text, \r\n    PossibleParPath text, \r\n    Offset          int, \r\n    Snapshot        text, \r\n    Volume          text\r\n)\r\n```\r\n\r\n### Useful queries\r\n\r\nThe following are useful queries.\r\n\r\n### Get all events\r\n    SELECT *\r\n    FROM EVENT\r\n\r\n#### CCleaner\r\n\r\n    SELECT *\r\n    FROM EVENT\r\n    WHERE filename REGEXP \"^[\\.zZ]+$\"\r\n\r\n#### Daily histogram\r\n\r\n    SELECT substr(event.Timestamp, 0, 11) AS day, count(*) AS count\r\n    FROM event\r\n    GROUP BY day\r\n\r\n\r\n## Understanding the output\r\n\r\nAll timestamps are in [ISO 8601 format](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations), \r\ni.e., YYYY-mm-dd HH:MM:SS.1234567.\r\nWindows stores timestamps as the number of hundred nanoseconds since 1601 \r\n(FILETIME). The routines used by NTFS-Linker to parse the time use standard \r\nC++ libraries, which may result in incorrect timestamps in some cases.\r\nSpecifically, if the time is _before_ 1970 or _after_ 2038, the timestamp will \r\nnot be displayed properly.\r\n\r\n### usn.txt\r\nThe [USN Journal reason code](https://msdn.microsoft.com/en-us/library/aa365722%28VS.85%29.aspx)\r\n uses a bit packing scheme for each possible \r\nreason. From the time a file is opened to the time it is closed, the reasons \r\nwill be combined. This means that multiple reasons may show up for a particular \r\nentry, even though only one operation happens at a time. The order the reasons \r\nare printed is completely arbitrary and has no correlation to the order in which \r\nthey occurred.\r\n\r\n#### USN Journal Example:\r\n- USN|FILE_CREATE\r\n- USN|CLOSE|FILE_CREATE\r\n- USN|DATA_EXTEND\r\n- USN|DATA_EXTEND|DATA_OVERWRITE\r\n- USN|BASIC_INFO_CHANGE|DATA_EXTEND|DATA_OVERWRITE\r\n- USN|BASIC_INFO_CHANGE|CLOSE|DATA_EXTEND|DATA_OVERWRITE\r\n\r\n### log.txt\r\n$LogFile event analysis is much more complicated.  Each record contains a redo \r\nand undo op code, as well as redo and undo data. In the case of data write \r\nevents, it is possible to recover the data written for resident files, or the \r\nfile sectors on disc for non-resident files. At this time NTFS-Linker does not \r\nrecover the data written.\r\n\r\n### events.txt\r\n\r\n#### Event Source\r\nThis can be `$UsnJrnl/$J`, `$LogFile`, or \"`$UsnJrnl` entry in `$LogFile`\". \r\n`$LogFile` actually contains complete `$UsnJrnl` entries.\r\n\r\n#### File names and paths\r\nWhile a file name can be extracted directly from a Log/Usn entry, the paths must\r\nbe calculated. The \"folder\" path is the calculated path to the parent directory,\r\nand the \"Path\" column is the calculated path to the MFT record number if \r\navailable.\r\n\r\n```gotta come back to this and edit for clarity... maybe an example?```\r\nNTFS-Linker tracks each record's parent over time. For events where a recordnum \r\nand a parent recordnum can be recovered, it's possible that, in ntfs-linker's\r\ncurrent conception of the file system, these records are unrelated! In this case\r\nthe \"Folder\" and \"Full Path\" columns of the event will be mismatched. Generally,\r\nthe \"Folder\" will represent the path to the parent folder where the event \r\noccurred, and \"Full Path\" will represent the path to the file which NTFS-Linker \r\npreviously thought was at that record. \r\n\r\n#### Event Ordering\r\nWhile the exact order of `$LogFile` and `$UsnJrnl` events is known, \r\nrespectively, the combined ordering is not. They must be ordered according to \r\nthe event timestamps. While the  timestamps for all `$UsnJrnl` events are known,\r\nthe timestamps for `$LogFile` rename, move, and delete events is not known.\r\nNote that, due to file system tunneling, the event time for a `$LogFile` creation\r\nevent is not the `$STANDARD_INFORMATION` attribute creation time. It is the SIA\r\n*modified* time.\r\n\r\nNTFS-Linker performs a \"zipper-merge\" of these two event sequences, which preserves\r\nthe relative position of events from the same sequence. This is accomplished by\r\nmaintaining a cursor at each sequence, and choosing the next event to be the one\r\nwith the larger timestamp, when both sequences are non-increasing. Since timestamps\r\nfor `$LogFile` rename, delete, and move events are not known, they are always placed\r\ndirectly after the preceding `$LogFile` creation event.\r\n\r\nThis can leave some uncertainty surrounding the exact time of an event,\r\nbut in practice there are almost always surrounding events which limit the uncertainty.\r\nFor example, the `$LogFile` events in the below snippet will almost certainly \r\nhave occurred between 2012-04-07 21:40:26.5203196 and 2012-04-07 21:39:07.3474312.\r\nSince identical events were found in `$UsnJrnl/$J`, we suspect these 3 files\r\nwere deleted at 2012-04-07 21:40:26.5203196.\r\n\r\n\r\n\r\n| Timestamp                   | Source      | Event  | File         |\r\n| --------------------------- | ----------- | ------ | ------------ |\r\n| 2012-04-07 21:40:26.5359448 |\t$LogFile    | Create | gpt00000.dom |\r\n| 2012-04-07 21:40:26.5359448 |\t$UsnJrnl/$J\t| Create | gpt00000.dom |\r\n| 2012-04-07 21:40:26.5203196 |\t$LogFile    | Create | tmpgptfl.inf |\r\n|                             | $LogFile    | Delete | tmpgptfl.inf |\r\n|                             | $LogFile    | Delete | gpt00000.dom |\r\n|                             | $LogFile\"\t| Delete | 5.tmp        |\r\n| 2012-04-07 21:40:26.5203196 |\t$UsnJrnl/$J\t| Create | tmpgptfl.inf |\r\n| 2012-04-07 21:40:26.5203196 |\t$UsnJrnl/$J\t| Delete | tmpgptfl.inf |\r\n| 2012-04-07 21:40:26.5203196 |\t$UsnJrnl/$J | Delete | gpt00000.dom |\r\n| 2012-04-07 21:39:07.3474312 | $LogFile    | Create | 5.ini        |\r\n\r\n\r\n\r\n#### Offset\r\nThe actual file offset (in decimal) to the beginning of the event record in the \r\nsource file.\r\n\r\n#### Created, Modified, Comment\r\nFor `$LogFile` create events, the timestamps from the Standard Information \r\nattribute (regardless of the faith NTFS-Linker places in them) and whether those \r\ntimestamps match the corresponding timestamps in the File Name Attribute. If \r\nnot, the \"Comment\" field will say ``. This allows for easy detection of \r\ntimestomping.\r\n\r\n#### `$UsnJrnl` event collapsing\r\n`$UsnJrnl` records are combined in events.txt to display one event for each \r\nlogical event that actually occurred. For instance, for a rename event, \r\n`$UsnJrnl` will contain at least two records: one containing the old name and \r\none containing the new name (and probably a couple other records, for the same \r\nevent). In contrast, `events.txt` displays this event just once. For \r\nthe `$UsnJrnl` events embedded in `$LogFile`, this same deduplication is performed,\r\nbut only amongst other `$UsnJrnl` events embedded in `$LogFile`. Since these\r\nembedded events are found less often, for rename and move events, it is generally\r\nnot possible to retrieve both the file name before and the file name after.\r\n\r\n## Implementation Details\r\n\r\nThis section contains notes on the inner-workings of NTFS-Linker. Specifically,\r\nwe outline the process by which NTFS-Linker recovers events from `$LogFile`, \r\n`$UsnJrnl:$J`, and `$MFT`. While the structures of these files are fairly well\r\nknown, their inter-related meaning requires explanation.\r\n\r\n### Background: Sequencing\r\n\r\nIn this document, by `sequence`, we mean some ordered collection of objects,\r\nwhich could possibly repeat. Given a sequence, we can obtain a `subsequence`\r\nby *removing* zero or more elements. For example, the following is a sequence:\r\n\r\n    25 67 38 97 58 94 29 66 23 92 60 8 47 50 98 28 13 91 61 72\r\n\r\nAnd the following are all subsequences of the above sequence:\r\n\r\n|     | Subsequence                                                | Note                    |\r\n| --- | ---------------------------------------------------------- | ----------------------- |\r\n| S1  | 25 67 38 97 58 94 29 66 23 92 60 8 47 50 98 28 13 91 61 72 | zero elements removed   |\r\n| S2  | 25 38 58 29 23 60 47 98 13 61                              | (some elements removed) |\r\n| S3  | 25 38 47 50 72                                             | (some elements removed) |\r\n\r\n\r\n### Changes in State\r\nPut simply, a filesystem event implies a change in state of the filesystem. When\r\nreporting on an event, it's often desirable to display that in the context of\r\nthe state of the filesystem. This should be done in the context of the\r\nfilesystem *at the time the event occurred*. For instance, suppose we know the\r\nstate of a filesystem at some point in time (say, from a base image) to be:\r\n\r\n| Recordnum | Full Path      |\r\n| --------- | -------------- |\r\n| 10        | /foo/bar       |\r\n| 11        | /foo/bar/a.txt |\r\n| 12        | /foo/bar/b.txt |\r\n\r\nSuppose that immediately prior to the filesystem being imaged, we know that\r\nan entry with recordnum 13, parent recordnum 10 named `some_name` was deleted. \r\nNow suppose that just before *that*, we know an entry with recordnum 14, parent\r\nrecordnum 13, named `file.txt` was deleted. What was the full path of this\r\nrecord *at the time it was deleted*? We know that it must have been\r\n`/foo/bar/some_name/file.txt`! Thus we observe it's necessary to accumulate\r\nchanges in state of the filesystem as events are processed, in order to recover\r\nthe context of each event.\r\n\r\n\r\n### Event Ordering\r\nAt some point we arrive at this situation: we have a sequence of events from\r\n`$UsnJrnl` and a sequence of events from `$LogFile`. For the `$UsnJrnl` events\r\nwe know the event timestamps, but for the `$LogFile` events we have less\r\ninformation. For `$LogFile` rename, move, and delete events, we are not able to\r\nrecover an event timestamp. Only for `$LogFile` create events are we able to\r\nrecover an event timestamp.\r\n\r\nThe impact is this: we know the order of events in `$UsnJrnl` and `$LogFile`\r\nseparately, and we have some idea of the times these events occurred, but we\r\ndon't know exactly how the two sequences fit together. In order to create a \r\nunified timeline of events, we do a standard zipper merge of the two sequences, \r\nbut only considering the `$Logfile` create event timestamps. Events of other \r\ntypes found in `$LogFile` will always be output directly after the preceding\r\n`$LogFile` create event.\r\n\r\n\r\n### Volume Shadows and Processing Order\r\nA Volume Shadow Copy represents a snapshot of a filesystem at a particular time.\r\nOften, multiple shadow copies may be present which are close together in time\r\n(for example, shadow copies created as a result of running system updates). In\r\nthis situation, `$UsnJrnl` and `$LogFile` may actually overlap some between the\r\nsnapshots. To deduplicate this, we defer to the older snapshot. We grab all\r\nevents from the oldest snapshot, then only the events not present in the oldest\r\nsnapshot from the next oldest, etc., until we've processed the base snapshot.\r\n\r\nTo output events, however, we need to process the Shadow Copies in the reverse\r\norder, with the most recent events first, because the most recent events imply\r\na change in state of the file system. Thus we process all the events from the\r\nbase image (not including events which are found in the most recent shadow\r\ncopy!), and then the most recent shadow copy, etc. In the end we get a timeline\r\nfrom the present extending into the past of unified events which are mostly in\r\nthe same order as the events occurred. _[ed: *mostly???*]_\r\n\r\n### Extracting events from `$UsnJrnl`\r\nWhen a file is created, renamed, moved, or deleted, `$UsnJrnl` will contain\r\nmultiple records for the same logical event. The records contain information\r\nsuch as data being written to the file, security changes, etc. For rename and\r\nmove events the old name/parent recordnum and new name/parent recordnum will be\r\nin separate `$UsnJrnl` records. NTFS-Linker will compress all of these records\r\ninto one logical event, depending on the event flags. This compression ends when\r\neither the `$UsnJrnl` Record recordnum changes or a CLOSE flag is signalled.\r\nIf the flags for a group of records indicate the file was neither created,\r\ndeleted, moved, or renamed, then the records are discarded.\r\n\r\n### Extracting events from `$LogFile`\r\n`$LogFile` records exist at a lower-level than `$UsnJrnl`, so extracting logical\r\nevents is more complicated. A `$LogFile` record consists of a RedoOp and an\r\nUndoOp code each possibly associated with some data.\r\n\r\nWe break apart the $LogFile records into logical\r\ntransactions ending with a record with `RedoOp=FORGET_TRANSACTION` and\r\n`UndoOp=COMPENSATION_LOG_RECORD`. From here, we consider the sequence of OpCodes\r\nand check if it has a subsequence which represents a particular event type. We\r\nlist the subsequences associated with each event type below:\r\n\r\n\r\n| Event Type  | Order | RedoOp Subsequence Entry          | UndoOp Subsequence Entry          |\r\n| ----------- | ----- | --------------------------------- | --------------------------------- |\r\n| Create      | 1     | SET_BITS_IN_NONRESIDENT_BIT_MAP   | CLEAR_BITS_IN_NONRESIDENT_BIT_MAP |\r\n| Create      | 2     | NOOP                              | DEALLOCATE_FILE_RECORD_SEGMENT    |\r\n| Create      | 3     | ADD_INDEX_ENTRY\\*                 | DELETE_INDEX_ENTRY\\*              |\r\n| Create      | 4     | INITIALIZE_FILE_RECORD_SEGMENT    | NOOP                              |\r\n| Create      | 5     | FORGET TRANSACTION                | COMPENSATION_LOG_RECORD           |\r\n| ----------- | ----- | --------------------------------- | --------------------------------- |\r\n| Delete      | 1     | DELETE_INDEX_ENTRY\\*              | ADD_INDEX_ENTRY\\*                 |\r\n| Delete      | 2     | DEALLOCATE_FILE_RECORD_SEGMENT    | INITIALIZE_FILE_RECORD_SEGMENT    |\r\n| Delete      | 3     | CLEAR_BITS_IN_NONRESIDENT_BIT_MAP | SET_BITS_IN_NONRESIDENT_BIT_MAP   |\r\n| Delete      | 4     | FORGET_TRANSACTION                | COMPENSATION_LOG_RECORD           |\r\n| ----------- | ----- | --------------------------------- | --------------------------------- |\r\n| Rename/Move | 1     | DELETE_INDEX_ENTRY\\*              | ADD_INDEX_ENTRY\\*                 |\r\n| Rename/Move | 2     | DELETE_ATTRIBUTE                  | CREATE_ATTRIBUTE                  |\r\n| Rename/Move | 3     | CREATE_ATTRIBUTE                  | DELETR_ATTRIBUTE                  |\r\n| Rename/Move | 4     | ADD_INDEX_ENTRY\\*                 | DELETE_INDEX_ENTRY\\*              |\r\n| Rename/Move | 5     | FORGET_TRANSACTION                | COMPENSATION_LOG_RECORD           |\r\n\r\n\r\nFor some of the above (RedoOp, UndoOp) pairs there is data associated with the operation\r\nwhich we add to the candidate event, which we list below:\r\n\r\n\r\n| RedoOp                          | UndoOp                            | Data Found                                              |\r\n| ------------------------------- | --------------------------------- | ------------------------------------------------------- |\r\n| SET_BITS_IN_NONRESIDENT_BIT_MAP | CLEAR_BITS_IN_NONRESIDENT_BIT_MAP | Recordnum                                               |\r\n| INITIALIZE_FILE_RECORD_SEGMENT  | NOOP                              | Complete MFT entry                                      |\r\n| DELETE_ATTRIBUTE                | CREATE_ATTRIBUTE                  | Previous file name                                      |\r\n| CREATE_ATTRIBUTE                | DELETE_ATTRIBUTE                  | New file name                                           |\r\n| DELETE_INDEX_ENTRY\\*            | ADD_INDEX_ENTRY\\*                 | File name, parent recordnum                             |\r\n| ADD_INDEX_ENTRY\\*               | DELETE_INDEX_ENTRY\\*              | Recordnum, Parent recordnum, Timestamp, (new) file name |\r\n| UPDATE_NONRESIDENT_VALUE        | NOOP                              | Embedded `$UsnJrnl` entry                               |\r\n\r\n\r\n\\***Note**: Throughout these tables, we consider ADD_INDEX_ENTRY_ALLOCATION to\r\nbe equivalent to ADD_INDEX_ENTRY_ROOT, and denote as ADD_INDEX ENTRY, and\r\nDELETE_INDEX_ENTRY_ALLOCATION equivalent to DELETE_INDEX_ENTRY_ROOT, and \r\ndenote as DELETE_INDEX_ENTRY.\r\n\r\nSo, the parsing strategy is to collect the above data as each record is\r\nprocessed, all the while checking if the transaction has ended. If it has, \r\nthen we mark a new event if it matches the above event type sequences. \r\nRegardless, the transaction data is cleared.\r\n\r\n## Further reading\r\n\r\nThere are a number of good resources online about NTFS, $MFT, $UsnJrnl, \r\n$Logfile, and Volume Shadow Copies. Among them:\r\n - [David Cowen](http://www.hecfblog.com/) has blogged in-depth about his \r\n research into NTFS linking and offers a [tool](http://www.gettriforce.com) \r\n that has features beyond the scope of NTFS-linker.\r\n\r\n   - [NTFS Triforce - A deeper look inside the artifacts](http://hackingexposedcomputerforensicsblog.blogspot.com/2013/01/ntfs-triforce-deeper-look-inside.html)\r\n\r\n   - [CEIC 2013 and the public beta of the NTFS Triforce](http://hackingexposedcomputerforensicsblog.blogspot.com/2013/05/ceic-2013-and-public-beta-of-ntfs.html)\r\n\r\n - The [Linux-NTFS documentation](http://0cch.net/ntfsdoc/) \r\n\r\n - [MSDN on the $UsnJrnl](http://www.microsoft.com/msj/0999/journal/journal.aspx)\r\n\r\n - Mike Wilkinson's [NTFS Cheat Sheet](http://www.writeblocked.org/resources/ntfs_cheat_sheets.pdf) \r\n is a succinct reference to various NTFS structures.\r\n\r\n - [NTFS Log Tracker](http://forensicinsight.org/wp-content/uploads/2013/06/F-INSIGHT-NTFS-Log-TrackerEnglish.pdf)\r\n for details on $LogFile transactions","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}